using Jotunn.Managers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.UI;
using WxAxW.PinAssistant.Patches;
using WxAxW.PinAssistant.Utils;
using Debug = WxAxW.PinAssistant.Utils.Debug;

namespace WxAxW.PinAssistant.Core
{
    internal class MinimapAssistant : PluginComponent
    {
        private static MinimapAssistant m_instance = new MinimapAssistant();

        private readonly Dictionary<string, PinGroup> m_pins = new Dictionary<string, PinGroup>();

        public static MinimapAssistant Instance { get => m_instance; private set => m_instance = value; }

        public override void Start()
        {
            MinimapPatches.OnPinAdd += OnPinAdd;
            MinimapPatches.OnPinRemove += OnPinRemove;
            MinimapPatches.OnPinUpdate += OnPinUpdate;
        }

        public override void Destroy()
        {
            MinimapPatches.OnPinAdd -= OnPinAdd;
            MinimapPatches.OnPinRemove -= OnPinRemove;
            MinimapPatches.OnPinUpdate -= OnPinUpdate;
            m_instance = null;
        }

        public override void OnEnable()
        {
            OnTrackedObjectsReload(TrackingAssistant.Instance.TrackedObjects);

            // check if instance exists
            TrackingAssistant.Instance.OnTrackedObjectAdd += OnTrackedObjectAdd;
            TrackingAssistant.Instance.OnTrackedObjectRemove += OnTrackedObjectRemove;
            TrackingAssistant.Instance.OnTrackedObjectUpdate += OnTrackedObjectUpdate;
            TrackingAssistant.Instance.OnTrackedObjectsReload += OnTrackedObjectsReload;
            MinimapPatches.OnPinsUpdate += OnMinimapUpdatePins;
        }

        public override void OnDisable()
        {
            TrackingAssistant.Instance.OnTrackedObjectAdd -= OnTrackedObjectAdd;
            TrackingAssistant.Instance.OnTrackedObjectRemove -= OnTrackedObjectRemove;
            TrackingAssistant.Instance.OnTrackedObjectUpdate -= OnTrackedObjectUpdate;
            TrackingAssistant.Instance.OnTrackedObjectsReload -= OnTrackedObjectsReload;
            MinimapPatches.OnPinsUpdate -= OnMinimapUpdatePins; // do not color pins when mod is disabled
        }

        public void ColorPins()
        {
            foreach (var kvp in m_pins)
            {
                kvp.Value.ApplyColor();
            }
        }

        private void PinAdd(Minimap.PinData pin)
        {
            PinGroup initializedPinGroup = InitializePinGroup(pin, Color.white);
            initializedPinGroup.Add(pin);
        }

        private PinGroup InitializePinGroup(Minimap.PinData newPin, Color pinColor)
        {
            return InitializeKey(GetPinKey(newPin), newPin.m_name, newPin.m_type, pinColor);
        }

        // Groups may exist naturally or generated by the plugin, if it was made naturally by manual player created pins, simply change the color instead when initializing.
        private PinGroup InitializeKey(string key, string pinName, Minimap.PinType pinType, Color pinColor, bool forceChangeColor = false)
        {
            if (!m_pins.TryGetValue(key, out PinGroup foundPinGroup))
            {
                Debug.Log($"Created colored pin group for {key}");
                PinGroup newPinGroup = new PinGroup(pinName, pinType, pinColor);
                m_pins.Add(key, newPinGroup);
                return newPinGroup;
            }

            if (forceChangeColor)
            {
                Debug.Log($"Colored pin group named, '{key}' exists, Changing the color only instead.");
                foundPinGroup.PinColor = pinColor;
            }
            return foundPinGroup;
        }

        public void ModifyPin(Minimap.PinData pinData, string newName, Minimap.PinType newType)
        {
            ModifyPin(pinData, pinData.m_name, newName, pinData.m_type, newType);
        }

        // Sometimes pins are immediately modified so we can't rely on pinData's m_name, it could be old or new, hence the extra arguments
        public void ModifyPin(Minimap.PinData pinData, string oldName, string newName, Minimap.PinType oldType, Minimap.PinType newType)
        {
            if (oldName.Equals(newName) && oldType == newType) return;
            Debug.Log($"Modifying {oldName} | {oldType} to {newName} | {newType}");

            string oldPinKey = GetPinKey(oldName, oldType);
            if (!m_pins.TryGetValue(oldPinKey, out PinGroup foundPinGroup))
            {
                Debug.Error("Pin group not found, contact dev");
                return;
            }
            if (!foundPinGroup.Remove(pinData))
            {
                Debug.Error("Pin not found in group, contact dev");
            }
            if (!oldName.Equals(newName)) PinHandler.SetPinName(pinData, newName);
            if (!oldType.Equals(newType)) PinHandler.SetPinType(pinData, newType);
            PinAdd(pinData);
        }

        private void TransferPinGroup(string oldPinsName, string newPinsName, Minimap.PinType oldType, Minimap.PinType newType)
        {
            if (newType == Minimap.PinType.None) return;
            if (oldPinsName.Equals(newPinsName) && oldType == newType) return;
            string newPinsKey = GetPinKey(newPinsName, newType);
            string oldPinsKey = GetPinKey(oldPinsName, oldType);
            if (!m_pins.ContainsKey(oldPinsKey)) return;
            PinGroup pinGroupToMerge = InitializeKey(newPinsKey, newPinsName, newType, Color.white);

            if (!m_pins.TryGetValue(oldPinsKey, out PinGroup oldPinGroup))
            {
                Debug.Log("No pins exists with current pin name and type.");
                return;
            }
            oldPinGroup.ModifyPins(newPinsName, newType);
            pinGroupToMerge.AddFormattedRange(oldPinGroup);
        }
        
        private string GetPinKey(Minimap.PinData pinData)
        {
            return GetPinKey(pinData.m_name, pinData.m_type);
        }
        private string GetPinKey(string pinName, Minimap.PinType pinType)
        {
            string formattedPinKey = pinName.ToLower() + "_" + pinType.ToString();
            return formattedPinKey;
        }
        
        public Color GetColor(Minimap.PinData pin)
        {
            if (!m_instance.m_pins.TryGetValue(m_instance.GetPinKey(pin), out PinGroup pinGroup)) return Color.white;
            return pinGroup.PinColor;
        }


        private void OnPinAdd(Minimap.PinData pin)
        {
            if (MinimapPatches.isSpecialPin) return;
            PinAdd(pin);
        }

        private void OnPinRemove(Minimap.PinData pin)
        {
            if (!m_pins.TryGetValue(GetPinKey(pin), out PinGroup oldPinGroup)) return;
            oldPinGroup.Remove(pin);
        }

        private void OnPinUpdate()
        {
            Minimap.PinData oldPin = MinimapPatches.m_edittingPinInitial;
            Minimap.PinData newPin = MinimapPatches.m_edittingPin;
            if (newPin == null) return;
            string oldName = oldPin.m_name;
            string newName = newPin.m_name;
            Minimap.PinType oldType = oldPin.m_type;
            Minimap.PinType newType = newPin.m_type;
            Debug.Log($"Updating pin from, {oldName} | {oldType}, to {newName} | {newType}");

            ModifyPin(newPin, oldName, newName, oldType, newType);
        }

        // Event that runs on every minimap updates, as the color reverts everytime Minimap.UpdatePins execute.
        private void OnMinimapUpdatePins()
        {
            ColorPins();
        }

        private void OnTrackedObjectAdd(TrackedObject trackedObject)
        {
            string pinName = trackedObject.Name;
            Minimap.PinType pinType = trackedObject.Icon;
            Color pinColor = trackedObject.PinColor;

            Debug.Log($"Initializing pin name storage for tracked object, {trackedObject.ObjectID}.");
            string pinKey = GetPinKey(pinName, pinType);
            
            InitializeKey(pinKey, pinName, pinType, pinColor, forceChangeColor: true);
        }

        private void OnTrackedObjectRemove(TrackedObject trackedObject)
        {
            string pinKey = GetPinKey(trackedObject.Name, trackedObject.Icon);
            if (!m_pins.TryGetValue(pinKey, out PinGroup pinGroup))
            {
                Debug.Error("Failed to remove group, contact dev!");
                return;
            }
            Debug.Log($"Removing color for {trackedObject.ObjectID}");
            pinGroup.PinColor = Color.white; // "remove" by changing the color to white
        }

        private void OnTrackedObjectUpdate(TrackedObject trackedObject, TrackedObject newTrackedObject, bool modifyPins)
        {
            string oldPinName = trackedObject.Name;
            Minimap.PinType oldPinType = trackedObject.Icon;
            string newPinName = newTrackedObject.Name;
            Minimap.PinType newPinType = newTrackedObject.Icon;
            if (oldPinName.Equals(newPinName) && oldPinType == newPinType) return;
            
            string oldPinKey = GetPinKey(oldPinName, oldPinType);
            if (!m_pins.TryGetValue(oldPinKey, out PinGroup pinGroup))
            {
                Debug.Error("Failed to update group, contact dev!");
                return;
            }
            if (modifyPins) TransferPinGroup(oldPinName, newPinName, oldPinType, newPinType);

            pinGroup.ResetColor();
            OnTrackedObjectAdd(newTrackedObject);
        }

        private void OnTrackedObjectsReload(LooseDictionary<TrackedObject> trackedObjects)
        {
            foreach (var item in m_pins)
            {
                item.Value.ResetColor();
            }

            foreach (var item in trackedObjects.AltDictionary.Values)
            {
                OnTrackedObjectAdd(item.Value);
            }
            Debug.Log("Minimap Pin color reloaded");
        }
    }
}