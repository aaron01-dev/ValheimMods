using Jotunn.Managers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.UI;
using WxAxW.PinAssistant.Patches;
using WxAxW.PinAssistant.Utils;
using Debug = WxAxW.PinAssistant.Utils.Debug;

namespace WxAxW.PinAssistant.Core
{
    internal class PinGroupHandler : PluginComponent
    {
        private static PinGroupHandler m_instance = new PinGroupHandler();

        private readonly Dictionary<string, PinGroup> m_pinGroups = new Dictionary<string, PinGroup>();

        public static PinGroupHandler Instance { get => m_instance; private set => m_instance = value; }

        public override void Start()
        {
            MinimapPatches.OnPinAdd += OnPinAdd;
            MinimapPatches.OnPinRemove += OnPinRemove;
            MinimapPatches.OnPinUpdate += OnPinUpdate;
        }

        public override void Destroy()
        {
            MinimapPatches.OnPinAdd -= OnPinAdd;
            MinimapPatches.OnPinRemove -= OnPinRemove;
            MinimapPatches.OnPinUpdate -= OnPinUpdate;
            m_instance = null;
        }

        public override void OnEnable()
        {
            OnTrackedObjectsReload(TrackingAssistant.Instance.TrackedObjects);

            // check if instance exists
            TrackingAssistant.Instance.OnTrackedObjectAdd += OnTrackedObjectAdd;
            TrackingAssistant.Instance.OnTrackedObjectRemove += OnTrackedObjectRemove;
            TrackingAssistant.Instance.OnTrackedObjectUpdate += OnTrackedObjectUpdate;
            TrackingAssistant.Instance.OnTrackedObjectsReload += OnTrackedObjectsReload;
            MinimapPatches.OnMinimapUpdatePins += OnMinimapUpdatePins;
        }

        public override void OnDisable()
        {
            TrackingAssistant.Instance.OnTrackedObjectAdd -= OnTrackedObjectAdd;
            TrackingAssistant.Instance.OnTrackedObjectRemove -= OnTrackedObjectRemove;
            TrackingAssistant.Instance.OnTrackedObjectUpdate -= OnTrackedObjectUpdate;
            TrackingAssistant.Instance.OnTrackedObjectsReload -= OnTrackedObjectsReload;
            MinimapPatches.OnMinimapUpdatePins -= OnMinimapUpdatePins; // do not color pins when mod is disabled
        }

        public void ColorPins()
        {
            foreach (var kvp in m_pinGroups)
            {
                kvp.Value.ApplyColor();
            }
        }

        private void AddPinToGroup(Minimap.PinData pin)
        {
            PinGroup initializedPinGroup = InitOrGetPinGroup(pin, Color.white);
            initializedPinGroup.Add(pin);
        }

        private PinGroup InitOrGetPinGroup(Minimap.PinData newPin, Color pinColor)
        {
            return InitOrGetPinGroup(GetPinKey(newPin), newPin.m_name, newPin.m_type, pinColor);
        }

        // Groups may exist naturally or generated by the plugin, if it was made naturally by manual player created pins, simply change the color instead when initializing.
        private PinGroup InitOrGetPinGroup(string key, string pinName, Minimap.PinType pinType, Color pinColor, bool forceChangeColor = false)
        {
            if (!m_pinGroups.TryGetValue(key, out PinGroup foundPinGroup))
            {
                Debug.Log($"Created pin group for {key}");
                PinGroup newPinGroup = new PinGroup(pinName, pinType, pinColor);
                m_pinGroups.Add(key, newPinGroup);
                return newPinGroup;
            }

            if (forceChangeColor)
            {
                Debug.Log($"Pin group named, '{key}' exists, Changing the color only instead.");
                foundPinGroup.PinColor = pinColor;
            }
            return foundPinGroup;
        }

        public void ModifyPin(Minimap.PinData pinData, string newName, Minimap.PinType newType)
        {
            ModifyPin(pinData, pinData.m_name, newName, pinData.m_type, newType);
        }

        // Sometimes pins are immediately modified so we can't rely on pinData's m_name, it could be old or new, hence the extra arguments
        public void ModifyPin(Minimap.PinData pinData, string oldName, string newName, Minimap.PinType oldType, Minimap.PinType newType)
        {
            if (oldName.Equals(newName) && oldType == newType) return;
            Debug.Log($"Modifying {oldName} | {oldType} to {newName} | {newType}");

            string oldPinKey = GetPinKey(oldName, oldType);
            if (!m_pinGroups.TryGetValue(oldPinKey, out PinGroup foundPinGroup))
            {
                Debug.Error("Pin group not found, contact dev");
                return;
            }
            if (!foundPinGroup.Remove(pinData))
            {
                Debug.Error("Pin not found in group, contact dev");
            }
            if (!oldName.Equals(newName)) PinHandler.SetPinName(pinData, newName);
            if (!oldType.Equals(newType)) PinHandler.SetPinType(pinData, newType);
            AddPinToGroup(pinData);
        }

        public void ModifyPinGroup(TrackedObject oldPinGroup, TrackedObject newPinGroup)
        {
            ModifyPinGroup(oldPinGroup.Name, newPinGroup.Name, oldPinGroup.Icon, newPinGroup.Icon, oldPinGroup.PinColor, newPinGroup.PinColor);
        }

        public void ModifyPinGroup(string oldPinsName, string newPinsName, Minimap.PinType oldType, Minimap.PinType newType, Color oldPinsColor, Color newPinsColor)
        {
            if (!oldPinsName.Equals(newPinsName) || oldType != newType)
            {
                TransferPinGroup(oldPinsName, newPinsName, oldType, newType, oldPinsColor, newPinsColor);
                return; // no need to change color because pins are already transferred
            }
            
            if (oldPinsColor == newPinsColor)
            {
                Debug.Log("No changes detected in pin group, skipping modification.");
                return;
            }

            // todo: switch all try get value old pins to direct access since we know it exists
            if (!m_pinGroups.TryGetValue(GetPinKey(oldPinsName, oldType), out PinGroup pinGroup))
            {
                Debug.Error("Pin group not found, contact dev");
                return;
            }

            pinGroup.PinColor = newPinsColor;
        }

        private void TransferPinGroup(string oldPinsName, string newPinsName, Minimap.PinType oldType, Minimap.PinType newType, Color oldPinsColor, Color newPinsColor)
        {
            if (newType == Minimap.PinType.None) { // Not possible
                Debug.Error("How did you manage to do this. Transfer was not successful as the Pin Icon is set to \"None\".");
                return;
            }
            string newPinsKey = GetPinKey(newPinsName, newType);
            string oldPinsKey = GetPinKey(oldPinsName, oldType);

            if (!m_pinGroups.TryGetValue(oldPinsKey, out PinGroup oldPinGroup))
            {
                Debug.Error("Initial Pin Group does not exist, transfer was not successful.");
                return;
            }

            PinGroup newPinGroup;
            bool pinGroupExists = m_pinGroups.TryGetValue(newPinsKey, out newPinGroup);
            if (!pinGroupExists)
            { 
                newPinGroup = InitOrGetPinGroup(newPinsKey, newPinsName, newType, newPinsColor);
            }
            oldPinGroup.TransferTo(newPinGroup);
            oldPinGroup.ResetColor(); // reset old pin group color to prevent color carry over
        }
        
        public static string GetPinKey(Minimap.PinData pinData)
        {
            return GetPinKey(pinData.m_name, pinData.m_type);
        }
        public static string GetPinKey(string pinName, Minimap.PinType pinType)
        {
            string formattedPinKey = pinName.ToLower() + "_" + pinType.ToString();
            return formattedPinKey;
        }
        
        public Color GetColor(Minimap.PinData pin)
        {
            if (!m_pinGroups.TryGetValue(GetPinKey(pin), out PinGroup pinGroup)) return Color.white;
            return pinGroup.PinColor;
        }


        private void OnPinAdd(Minimap.PinData pin)
        {
            if (MinimapPatches.isSpecialPin) return;
            AddPinToGroup(pin);
        }

        private void OnPinRemove(Minimap.PinData pin)
        {
            if (!m_pinGroups.TryGetValue(GetPinKey(pin), out PinGroup oldPinGroup)) return;
            oldPinGroup.Remove(pin);
        }

        private void OnPinUpdate(Minimap.PinData oldPin, Minimap.PinData newPin)
        {
            if (newPin == null) return;
            string oldName = oldPin.m_name;
            string newName = newPin.m_name;
            Minimap.PinType oldType = oldPin.m_type;
            Minimap.PinType newType = newPin.m_type;
            Debug.Log($"Updating pin from, {oldName} | {oldType}, to {newName} | {newType}");

            ModifyPin(newPin, oldName, newName, oldType, newType);
        }

        // Event that runs on every minimap updates, as the color reverts everytime Minimap.UpdatePins execute.
        private void OnMinimapUpdatePins()
        {
            ColorPins();
        }

        private void OnTrackedObjectAdd(TrackedObject trackedObject)
        {
            string pinName = trackedObject.Name;
            Minimap.PinType pinType = trackedObject.Icon;
            Color pinColor = trackedObject.PinColor;

            Debug.Log($"Initializing pin name storage for tracked object, {trackedObject.ObjectID}.");
            string pinKey = GetPinKey(pinName, pinType);
            
            InitOrGetPinGroup(pinKey, pinName, pinType, pinColor, forceChangeColor: true);
        }

        private void OnTrackedObjectRemove(TrackedObject trackedObject)
        {
            string pinKey = GetPinKey(trackedObject.Name, trackedObject.Icon);
            if (!m_pinGroups.TryGetValue(pinKey, out PinGroup pinGroup))
            {
                Debug.Error("Failed to remove group, contact dev!");
                return;
            }
            Debug.Log($"Removing color for {trackedObject.ObjectID}");
            pinGroup.PinColor = Color.white; // "remove" by changing the color to white
        }

        private void OnTrackedObjectUpdate(TrackedObject trackedObject, TrackedObject newTrackedObject, bool modifyPins)
        {
            string oldPinName = trackedObject.Name;
            Minimap.PinType oldPinType = trackedObject.Icon;
            string newPinName = newTrackedObject.Name;
            Minimap.PinType newPinType = newTrackedObject.Icon;

            string keyOld = GetPinKey(oldPinName, oldPinType);
            string keyNew = GetPinKey(newPinName, newPinType);

            bool noKeyChanges = keyOld.Equals(keyNew);
            if (!m_pinGroups.TryGetValue(keyOld, out PinGroup pinGroup))
            {
                Debug.Error("Failed to update group, contact dev!");
                return;
            }
            // No changes detected no need to modify, only change color, won't do anything if new color is the same
            if (noKeyChanges)
            {
                pinGroup.PinColor = newTrackedObject.PinColor;
            } 
            else 
            {
                if (modifyPins) ModifyPinGroup(trackedObject, newTrackedObject); // This will also reset the color of the old pin group
                else // TrackedObject is no longer affecting this Pin Group, reset its color and initialize or get the new pin group
                {
                    // todo: when pin group removal is added, move "isTracked" from old pin group to new pin group here
                    InitOrGetPinGroup(keyNew, newPinName, newPinType, newTrackedObject.PinColor, forceChangeColor: true);
                    pinGroup.ResetColor(); // just reset the color of the old pin group
                }
            }
        }

        private void OnTrackedObjectsReload(LooseDictionary<TrackedObject> trackedObjects)
        {
            foreach (var item in m_pinGroups)
            {
                item.Value.ResetColor();
            }

            foreach (var item in trackedObjects.AltDictionary.Values)
            {
                OnTrackedObjectAdd(item.Value);
            }
            Debug.Log("Minimap Pin color reloaded");
        }
    }
}